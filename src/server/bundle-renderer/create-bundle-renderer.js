/* @flow */

import { createPromiseCallback } from '../util'
import { createBundleRunner } from './create-bundle-runner'
import type { Renderer, RenderOptions } from '../create-renderer'
import { createSourceMapConsumers, rewriteErrorTrace } from './source-map-support'

const fs = require('fs')
const path = require('path')
const PassThrough = require('stream').PassThrough

const INVALID_MSG =
  'Invalid server-rendering bundle format. Should be a string ' +
  'or a bundle Object of type:\n\n' +
`{
  entry: string;
  files: { [filename: string]: string; };
  maps: { [filename: string]: string; };
}\n`

// The render bundle can either be a string (single bundled file)
// or a bundle manifest object generated by vue-ssr-webpack-plugin.
type RenderBundle = {
  basedir?: string; // vue-ssr-server-bundle.json文件（从bundle参数传入）的目录
  entry: string; // 入口模块文件的路径
  files: { [filename: string]: string; }; // 模块文件名称与内容的额映射
  maps: { [filename: string]: string; }; // 模块文件名称与source map内容的映射
  modules?: { [filename: string]: Array<string> };
};

/**
 * 创建能创建BundleRenderer对象的工厂函数
 * @param {Function} createRenderer renderer对象的工厂函数
 * @returns createBundleRenderer函数
 */
export function createBundleRendererCreator (
  createRenderer: (options?: RenderOptions) => Renderer
) {
  /**
  * 创建BundleRenderer对象，该对象由两个渲染方法组成
  * @param {string | RenderBundle} bundle JSON对象，或（JSON或js）文件路径。通过使用 webpack 的vue-server-renderer/server-plugin插件，server bundle 将生成为可传递到 bundle renderer 的特殊 JSON 文件
  * @param {RenderOptions} rendererOptions 配置对象，见../create-renderer.js中的RenderOptions类型定义
  * @returns 由两个渲染方法组成的对象
  */
  return function createBundleRenderer (
    bundle: string | RenderBundle,
    rendererOptions?: RenderOptions = {}
  ) {
    let files, entry, maps
    let basedir = rendererOptions.basedir

    // load bundle if given filepath
    if (
      typeof bundle === 'string' && // bundle为文件路径
      /\.js(on)?$/.test(bundle) && // 为js或json文件的路径
      path.isAbsolute(bundle) // 为绝对路径
    ) {
      if (fs.existsSync(bundle)) { // 文件存在
        const isJSON = /\.json$/.test(bundle)
        basedir = basedir || path.dirname(bundle) // 读取vue-ssr-server-bundle.json文件（从bundle参数传入）的目录
        bundle = fs.readFileSync(bundle, 'utf-8') // 读文件
        if (isJSON) {
          try {
            bundle = JSON.parse(bundle) // 文件内容转json
          } catch (e) {
            throw new Error(`Invalid JSON bundle file: ${bundle}`)
          }
        }
      } else {
        throw new Error(`Cannot locate bundle file: ${bundle}`)
      }
    }

    if (typeof bundle === 'object') { // bundle为对象
      entry = bundle.entry // 入口模块文件的路径
      files = bundle.files // 模块文件名与文件内容的映射
      basedir = basedir || bundle.basedir // vue-ssr-server-bundle.json文件（从bundle参数传入）的目录
      maps = createSourceMapConsumers(bundle.maps) // 返回模块文件路径到 能表示一个经过解析的source map文件的实例（SourceMapConsumer的实例） 的映射
      if (typeof entry !== 'string' || typeof files !== 'object') {
        throw new Error(INVALID_MSG)
      }
    } else if (typeof bundle === 'string') { // bundle为字符串（js文件的内容），即最初传入的bundle为js文件
      entry = '__vue_ssr_bundle__'
      files = { '__vue_ssr_bundle__': bundle }
      maps = {}
    } else {
      throw new Error(INVALID_MSG)
    }

    const renderer = createRenderer(rendererOptions) // 创建renderer对象。该对象由两个渲染方法组成的对象，一个是将Vue实例和模板渲染成完成HTMl文件内容，一个是将Vue实例，或加上模板，渲染结束，返回流对象

    const run = createBundleRunner( // 创建一个可以能执行entry模块脚本的函数
      entry,
      files,
      basedir,
      rendererOptions.runInNewContext
    )

    return {
      /**
       * 执行entry模块的导出函数，导出函数的执行结果是一个Promise实例，该Promise实例内部返回的是Vue实例。
       * 渲染该Vue实例，或返回Promise实例，在Promise实例中返回渲染结果，或在cb中返回渲染结果。
       * 所以在SSR项目中，webpack的server端渲染的入口，需要导出(context) => { return new Promise((resolve, reject) => { ...resolve(new Vue(...)) }) }
       * @param {Object} context 渲染上下文
       * @param {Function} cb 回调函数第一个参数为error，第二个参数为渲染完成的完整的HTMl文件内容
       * @returns 如果未传入cb，则返回Promise实例
       */
      renderToString: (context?: Object, cb: any) => {
        if (typeof context === 'function') { // 处理之传入一个参数的情况
          cb = context
          context = {}
        }

        let promise
        if (!cb) { // // 如果未传入回调函数，则创建Promise实例，在本函数最后返回
          ({ promise, cb } = createPromiseCallback())
        }

        run(context).catch(err => { // 执行entry模块导出的函数
          rewriteErrorTrace(err, maps)
          cb(err)
        }).then(app => {
          if (app) {
            renderer.renderToString(app, context, (err, res) => {
              rewriteErrorTrace(err, maps)
              cb(err, res)
            })
          }
        })

        return promise
      },

      /**
       * 执行entry模块的导出函数，导出函数的执行结果是一个Promise实例，该Promise实例内部返回的是Vue实例
       * 渲染该Vue实例，返回渲染结果的可读取流对象
       * @param {Object} context 渲染上下文
       * @returns 将Vue实例渲染成的可读取的流对象，如果存在template则为完整的HTML文件内容的流对象，否则为component渲染结果的流对象
       */
      renderToStream: (context?: Object) => {
        const res = new PassThrough() // 转换流，用于将文本输出
        run(context).catch(err => { // 执行entry模块导出的函数
          rewriteErrorTrace(err, maps) //  转换Error内出错的位置为原始文件的位置
          // avoid emitting synchronously before user can
          // attach error listener
          process.nextTick(() => {
            res.emit('error', err) // 触发事件
          })
        }).then(app => {
          if (app) {
            const renderStream = renderer.renderToStream(app, context) // 将component渲染成可读取的流对象，如果存在template则为完整的HTML文件内容的流对象，否则为component渲染结果的流对象

            renderStream.on('error', err => {
              rewriteErrorTrace(err, maps)
              res.emit('error', err)
            })

            // relay HTMLStream special events
            if (rendererOptions && rendererOptions.template) { // 存在模板，处理渲染流到转换流的事件对应关系
              renderStream.on('beforeStart', () => {
                res.emit('beforeStart')
              })
              renderStream.on('beforeEnd', () => {
                res.emit('beforeEnd')
              })
            }

            renderStream.pipe(res) // 将渲染流传入到转换流
          }
        })

        return res // 返回转换流
      }
    }
  }
}
